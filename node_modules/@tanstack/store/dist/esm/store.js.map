{"version":3,"file":"store.js","sources":["../../src/store.ts"],"sourcesContent":["import { createAtom, toObserver } from './atom'\nimport type { Atom, Observer, Subscription } from './types'\n\nexport class Store<T> {\n  private atom: Atom<T>\n  constructor(getValue: (prev?: NoInfer<T>) => T)\n  constructor(initialValue: T)\n  constructor(valueOrFn: T | ((prev?: T) => T)) {\n    // createAtom has overloads that return ReadonlyAtom<T> for functions and Atom<T> for values\n    // Store always needs Atom<T> for setState, so we assert the return type\n    this.atom = createAtom(\n      valueOrFn as T | ((prev?: NoInfer<T>) => T),\n    ) as Atom<T>\n  }\n  public setState(updater: (prev: T) => T) {\n    this.atom.set(updater)\n  }\n  public get state() {\n    return this.atom.get()\n  }\n  public get() {\n    return this.state\n  }\n  public subscribe(\n    observerOrFn: Observer<T> | ((value: T) => void),\n  ): Subscription {\n    return this.atom.subscribe(toObserver(observerOrFn))\n  }\n}\n\nexport class ReadonlyStore<T> implements Omit<Store<T>, 'setState'> {\n  private atom: Atom<T>\n  constructor(getValue: (prev?: NoInfer<T>) => T)\n  constructor(initialValue: T)\n  constructor(valueOrFn: T | ((prev?: T) => T)) {\n    // createAtom has overloads that return ReadonlyAtom<T> for functions and Atom<T> for values\n    // Store always needs Atom<T> for setState, so we assert the return type\n    this.atom = createAtom(\n      valueOrFn as T | ((prev?: NoInfer<T>) => T),\n    ) as Atom<T>\n  }\n  public get state() {\n    return this.atom.get()\n  }\n  public get() {\n    return this.state\n  }\n  public subscribe(\n    observerOrFn: Observer<T> | ((value: T) => void),\n  ): Subscription {\n    return this.atom.subscribe(toObserver(observerOrFn))\n  }\n}\n\nexport function createStore<T>(\n  getValue: (prev?: NoInfer<T>) => T,\n): ReadonlyStore<T>\nexport function createStore<T>(initialValue: T): Store<T>\nexport function createStore<T>(\n  valueOrFn: T | ((prev?: T) => T),\n): Store<T> | ReadonlyStore<T> {\n  if (typeof valueOrFn === 'function') {\n    return new ReadonlyStore(valueOrFn as (prev?: NoInfer<T>) => T)\n  }\n  return new Store(valueOrFn)\n}\n"],"names":[],"mappings":";AAGO,MAAM,MAAS;AAAA,EAIpB,YAAY,WAAkC;AAG5C,SAAK,OAAO;AAAA,MACV;AAAA,IAAA;AAAA,EAEJ;AAAA,EACO,SAAS,SAAyB;AACvC,SAAK,KAAK,IAAI,OAAO;AAAA,EACvB;AAAA,EACA,IAAW,QAAQ;AACjB,WAAO,KAAK,KAAK,IAAA;AAAA,EACnB;AAAA,EACO,MAAM;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EACO,UACL,cACc;AACd,WAAO,KAAK,KAAK,UAAU,WAAW,YAAY,CAAC;AAAA,EACrD;AACF;AAEO,MAAM,cAAuD;AAAA,EAIlE,YAAY,WAAkC;AAG5C,SAAK,OAAO;AAAA,MACV;AAAA,IAAA;AAAA,EAEJ;AAAA,EACA,IAAW,QAAQ;AACjB,WAAO,KAAK,KAAK,IAAA;AAAA,EACnB;AAAA,EACO,MAAM;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EACO,UACL,cACc;AACd,WAAO,KAAK,KAAK,UAAU,WAAW,YAAY,CAAC;AAAA,EACrD;AACF;AAMO,SAAS,YACd,WAC6B;AAC7B,MAAI,OAAO,cAAc,YAAY;AACnC,WAAO,IAAI,cAAc,SAAqC;AAAA,EAChE;AACA,SAAO,IAAI,MAAM,SAAS;AAC5B;"}