{"version":3,"file":"alien.cjs","sources":["../../src/alien.ts"],"sourcesContent":["/* eslint-disable */\n// Adapted from Alien Signals\n// https://github.com/stackblitz/alien-signals/\n\nexport interface ReactiveNode {\n  deps?: Link\n  depsTail?: Link\n  subs?: Link\n  subsTail?: Link\n  flags: ReactiveFlags\n}\n\nexport interface Link {\n  version: number\n  dep: ReactiveNode\n  sub: ReactiveNode\n  prevSub: Link | undefined\n  nextSub: Link | undefined\n  prevDep: Link | undefined\n  nextDep: Link | undefined\n}\n\ninterface Stack<T> {\n  value: T\n  prev: Stack<T> | undefined\n}\n\nexport const enum ReactiveFlags {\n  None = 0,\n  Mutable = 1,\n  Watching = 2,\n  RecursedCheck = 4,\n  Recursed = 8,\n  Dirty = 16,\n  Pending = 32,\n}\n\nexport function createReactiveSystem({\n  update,\n  notify,\n  unwatched,\n}: {\n  update(sub: ReactiveNode): boolean\n  notify(sub: ReactiveNode): void\n  unwatched(sub: ReactiveNode): void\n}) {\n  return {\n    link,\n    unlink,\n    propagate,\n    checkDirty,\n    shallowPropagate,\n  }\n\n  function link(dep: ReactiveNode, sub: ReactiveNode, version: number): void {\n    const prevDep = sub.depsTail\n    if (prevDep !== undefined && prevDep.dep === dep) {\n      return\n    }\n    const nextDep = prevDep !== undefined ? prevDep.nextDep : sub.deps\n    if (nextDep !== undefined && nextDep.dep === dep) {\n      nextDep.version = version\n      sub.depsTail = nextDep\n      return\n    }\n    const prevSub = dep.subsTail\n    if (\n      prevSub !== undefined &&\n      prevSub.version === version &&\n      prevSub.sub === sub\n    ) {\n      return\n    }\n    const newLink =\n      (sub.depsTail =\n      dep.subsTail =\n        {\n          version,\n          dep,\n          sub,\n          prevDep,\n          nextDep,\n          prevSub,\n          nextSub: undefined,\n        })\n    if (nextDep !== undefined) {\n      nextDep.prevDep = newLink\n    }\n    if (prevDep !== undefined) {\n      prevDep.nextDep = newLink\n    } else {\n      sub.deps = newLink\n    }\n    if (prevSub !== undefined) {\n      prevSub.nextSub = newLink\n    } else {\n      dep.subs = newLink\n    }\n  }\n\n  function unlink(link: Link, sub = link.sub): Link | undefined {\n    const dep = link.dep\n    const prevDep = link.prevDep\n    const nextDep = link.nextDep\n    const nextSub = link.nextSub\n    const prevSub = link.prevSub\n    if (nextDep !== undefined) {\n      nextDep.prevDep = prevDep\n    } else {\n      sub.depsTail = prevDep\n    }\n    if (prevDep !== undefined) {\n      prevDep.nextDep = nextDep\n    } else {\n      sub.deps = nextDep\n    }\n    if (nextSub !== undefined) {\n      nextSub.prevSub = prevSub\n    } else {\n      dep.subsTail = prevSub\n    }\n    if (prevSub !== undefined) {\n      prevSub.nextSub = nextSub\n    } else if ((dep.subs = nextSub) === undefined) {\n      unwatched(dep)\n    }\n    return nextDep\n  }\n\n  function propagate(link: Link): void {\n    let next = link.nextSub\n    let stack: Stack<Link | undefined> | undefined\n\n    top: do {\n      const sub = link.sub\n      let flags = sub.flags\n\n      if (\n        !(\n          flags &\n          (ReactiveFlags.RecursedCheck |\n            ReactiveFlags.Recursed |\n            ReactiveFlags.Dirty |\n            ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags = flags | ReactiveFlags.Pending\n      } else if (\n        !(flags & (ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = ReactiveFlags.None\n      } else if (!(flags & ReactiveFlags.RecursedCheck)) {\n        sub.flags = (flags & ~ReactiveFlags.Recursed) | ReactiveFlags.Pending\n      } else if (\n        !(flags & (ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags = flags | (ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= ReactiveFlags.Mutable\n      } else {\n        flags = ReactiveFlags.None\n      }\n\n      if (flags & ReactiveFlags.Watching) {\n        notify(sub)\n      }\n\n      if (flags & ReactiveFlags.Mutable) {\n        const subSubs = sub.subs\n        if (subSubs !== undefined) {\n          const nextSub = (link = subSubs).nextSub\n          if (nextSub !== undefined) {\n            stack = { value: next, prev: stack }\n            next = nextSub\n          }\n          continue\n        }\n      }\n\n      if ((link = next!) !== undefined) {\n        next = link.nextSub\n        continue\n      }\n\n      while (stack !== undefined) {\n        link = stack.value!\n        stack = stack.prev\n        if (link !== undefined) {\n          next = link.nextSub\n          continue top\n        }\n      }\n\n      break\n    } while (true)\n  }\n\n  function checkDirty(link: Link, sub: ReactiveNode): boolean {\n    let stack: Stack<Link> | undefined\n    let checkDepth = 0\n    let dirty = false\n\n    top: do {\n      const dep = link.dep\n      const flags = dep.flags\n\n      if (sub.flags & ReactiveFlags.Dirty) {\n        dirty = true\n      } else if (\n        (flags & (ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n        (ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n      ) {\n        if (update(dep)) {\n          const subs = dep.subs!\n          if (subs.nextSub !== undefined) {\n            shallowPropagate(subs)\n          }\n          dirty = true\n        }\n      } else if (\n        (flags & (ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n        (ReactiveFlags.Mutable | ReactiveFlags.Pending)\n      ) {\n        if (link.nextSub !== undefined || link.prevSub !== undefined) {\n          stack = { value: link, prev: stack }\n        }\n        link = dep.deps!\n        sub = dep\n        ++checkDepth\n        continue\n      }\n\n      if (!dirty) {\n        const nextDep = link.nextDep\n        if (nextDep !== undefined) {\n          link = nextDep\n          continue\n        }\n      }\n\n      while (checkDepth--) {\n        const firstSub = sub.subs!\n        const hasMultipleSubs = firstSub.nextSub !== undefined\n        if (hasMultipleSubs) {\n          link = stack!.value\n          stack = stack!.prev\n        } else {\n          link = firstSub\n        }\n        if (dirty) {\n          if (update(sub)) {\n            if (hasMultipleSubs) {\n              shallowPropagate(firstSub)\n            }\n            sub = link.sub\n            continue\n          }\n          dirty = false\n        } else {\n          sub.flags &= ~ReactiveFlags.Pending\n        }\n        sub = link.sub\n        const nextDep = link.nextDep\n        if (nextDep !== undefined) {\n          link = nextDep\n          continue top\n        }\n      }\n\n      return dirty\n    } while (true)\n  }\n\n  function shallowPropagate(link: Link): void {\n    do {\n      const sub = link.sub\n      const flags = sub.flags\n      if (\n        (flags & (ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n        ReactiveFlags.Pending\n      ) {\n        sub.flags = flags | ReactiveFlags.Dirty\n        if (\n          (flags & (ReactiveFlags.Watching | ReactiveFlags.RecursedCheck)) ===\n          ReactiveFlags.Watching\n        ) {\n          notify(sub)\n        }\n      }\n    } while ((link = link.nextSub!) !== undefined)\n  }\n\n  function isValidLink(checkLink: Link, sub: ReactiveNode): boolean {\n    let link = sub.depsTail\n    while (link !== undefined) {\n      if (link === checkLink) {\n        return true\n      }\n      link = link.prevDep\n    }\n    return false\n  }\n}\n\ninterface EffectNode extends ReactiveNode {\n  fn(): void\n}\n\ninterface ComputedNode<T = any> extends ReactiveNode {\n  value: T | undefined\n  getter: (previousValue?: T) => T\n}\n\ninterface SignalNode<T = any> extends ReactiveNode {\n  currentValue: T\n  pendingValue: T\n}\n\nlet cycle = 0\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst queued: (EffectNode | undefined)[] = []\nconst { link, unlink, propagate, checkDirty, shallowPropagate } =\n  createReactiveSystem({\n    update(node: SignalNode | ComputedNode): boolean {\n      if (node.depsTail !== undefined) {\n        return updateComputed(node as ComputedNode)\n      } else {\n        return updateSignal(node as SignalNode)\n      }\n    },\n    notify(effect: EffectNode) {\n      let insertIndex = queuedLength\n      let firstInsertedIndex = insertIndex\n\n      do {\n        queued[insertIndex++] = effect\n        effect.flags &= ~ReactiveFlags.Watching\n        effect = effect.subs?.sub as EffectNode\n        if (effect === undefined || !(effect.flags & ReactiveFlags.Watching)) {\n          break\n        }\n      } while (true)\n\n      queuedLength = insertIndex\n\n      while (firstInsertedIndex < --insertIndex) {\n        const left = queued[firstInsertedIndex]\n        queued[firstInsertedIndex++] = queued[insertIndex]\n        queued[insertIndex] = left\n      }\n    },\n    unwatched(node) {\n      if (!(node.flags & ReactiveFlags.Mutable)) {\n        effectScopeOper.call(node)\n      } else if (node.depsTail !== undefined) {\n        node.depsTail = undefined\n        node.flags = ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        purgeDeps(node)\n      }\n    },\n  })\n\nexport function getActiveSub(): ReactiveNode | undefined {\n  return activeSub\n}\n\nexport function setActiveSub(sub?: ReactiveNode) {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nexport function getBatchDepth(): number {\n  return batchDepth\n}\n\nexport function startBatch() {\n  ++batchDepth\n}\n\nexport function endBatch() {\n  if (!--batchDepth) {\n    flush()\n  }\n}\n\nexport function isSignal(fn: () => void): boolean {\n  return fn.name === 'bound ' + signalOper.name\n}\n\nexport function isComputed(fn: () => void): boolean {\n  return fn.name === 'bound ' + computedOper.name\n}\n\nexport function isEffect(fn: () => void): boolean {\n  return fn.name === 'bound ' + effectOper.name\n}\n\nexport function isEffectScope(fn: () => void): boolean {\n  return fn.name === 'bound ' + effectScopeOper.name\n}\n\nexport function signal<T>(): {\n  (): T | undefined\n  (value: T | undefined): void\n}\nexport function signal<T>(initialValue: T): {\n  (): T\n  (value: T): void\n}\nexport function signal<T>(initialValue?: T): {\n  (): T | undefined\n  (value: T | undefined): void\n} {\n  return signalOper.bind({\n    currentValue: initialValue,\n    pendingValue: initialValue,\n    subs: undefined,\n    subsTail: undefined,\n    flags: ReactiveFlags.Mutable,\n  }) as () => T | undefined\n}\n\nexport function computed<T>(getter: (previousValue?: T) => T): () => T {\n  return computedOper.bind({\n    value: undefined,\n    subs: undefined,\n    subsTail: undefined,\n    deps: undefined,\n    depsTail: undefined,\n    flags: ReactiveFlags.None,\n    getter: getter as (previousValue?: unknown) => unknown,\n  }) as () => T\n}\n\nexport function effect(fn: () => void): () => void {\n  const e: EffectNode = {\n    fn,\n    subs: undefined,\n    subsTail: undefined,\n    deps: undefined,\n    depsTail: undefined,\n    flags: ReactiveFlags.Watching | ReactiveFlags.RecursedCheck,\n  }\n  const prevSub = setActiveSub(e)\n  if (prevSub !== undefined) {\n    link(e, prevSub, 0)\n  }\n  try {\n    e.fn()\n  } finally {\n    activeSub = prevSub\n    e.flags &= ~ReactiveFlags.RecursedCheck\n  }\n  return effectOper.bind(e)\n}\n\nexport function effectScope(fn: () => void): () => void {\n  const e: ReactiveNode = {\n    deps: undefined,\n    depsTail: undefined,\n    subs: undefined,\n    subsTail: undefined,\n    flags: ReactiveFlags.None,\n  }\n  const prevSub = setActiveSub(e)\n  if (prevSub !== undefined) {\n    link(e, prevSub, 0)\n  }\n  try {\n    fn()\n  } finally {\n    activeSub = prevSub\n  }\n  return effectScopeOper.bind(e)\n}\n\nexport function trigger(fn: () => void) {\n  const sub: ReactiveNode = {\n    deps: undefined,\n    depsTail: undefined,\n    flags: ReactiveFlags.Watching,\n  }\n  const prevSub = setActiveSub(sub)\n  try {\n    fn()\n  } finally {\n    activeSub = prevSub\n    let link = sub.deps\n    while (link !== undefined) {\n      const dep = link.dep\n      link = unlink(link, sub)\n      const subs = dep.subs\n      if (subs !== undefined) {\n        sub.flags = ReactiveFlags.None\n        propagate(subs)\n        shallowPropagate(subs)\n      }\n    }\n    if (!batchDepth) {\n      flush()\n    }\n  }\n}\n\nfunction updateComputed(c: ComputedNode): boolean {\n  ++cycle\n  c.depsTail = undefined\n  c.flags = ReactiveFlags.Mutable | ReactiveFlags.RecursedCheck\n  const prevSub = setActiveSub(c)\n  try {\n    const oldValue = c.value\n    return oldValue !== (c.value = c.getter(oldValue))\n  } finally {\n    activeSub = prevSub\n    c.flags &= ~ReactiveFlags.RecursedCheck\n    purgeDeps(c)\n  }\n}\n\nfunction updateSignal(s: SignalNode): boolean {\n  s.flags = ReactiveFlags.Mutable\n  return s.currentValue !== (s.currentValue = s.pendingValue)\n}\n\nfunction run(e: EffectNode): void {\n  const flags = e.flags\n  if (\n    flags & ReactiveFlags.Dirty ||\n    (flags & ReactiveFlags.Pending && checkDirty(e.deps!, e))\n  ) {\n    ++cycle\n    e.depsTail = undefined\n    e.flags = ReactiveFlags.Watching | ReactiveFlags.RecursedCheck\n    const prevSub = setActiveSub(e)\n    try {\n      ;(e as EffectNode).fn()\n    } finally {\n      activeSub = prevSub\n      e.flags &= ~ReactiveFlags.RecursedCheck\n      purgeDeps(e)\n    }\n  } else {\n    e.flags = ReactiveFlags.Watching\n  }\n}\n\nfunction flush(): void {\n  try {\n    while (notifyIndex < queuedLength) {\n      const effect = queued[notifyIndex]!\n      queued[notifyIndex++] = undefined\n      run(effect)\n    }\n  } finally {\n    while (notifyIndex < queuedLength) {\n      const effect = queued[notifyIndex]!\n      queued[notifyIndex++] = undefined\n      effect.flags |= ReactiveFlags.Watching | ReactiveFlags.Recursed\n    }\n    notifyIndex = 0\n    queuedLength = 0\n  }\n}\n\nfunction computedOper<T>(this: ComputedNode<T>): T {\n  const flags = this.flags\n  if (\n    flags & ReactiveFlags.Dirty ||\n    (flags & ReactiveFlags.Pending &&\n      (checkDirty(this.deps!, this) ||\n        ((this.flags = flags & ~ReactiveFlags.Pending), false)))\n  ) {\n    if (updateComputed(this)) {\n      const subs = this.subs\n      if (subs !== undefined) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (!flags) {\n    this.flags = ReactiveFlags.Mutable | ReactiveFlags.RecursedCheck\n    const prevSub = setActiveSub(this)\n    try {\n      this.value = this.getter()\n    } finally {\n      activeSub = prevSub\n      this.flags &= ~ReactiveFlags.RecursedCheck\n    }\n  }\n  const sub = activeSub\n  if (sub !== undefined) {\n    link(this, sub, cycle)\n  }\n  return this.value!\n}\n\nfunction signalOper<T>(this: SignalNode<T>, ...value: [T]): T | void {\n  if (value.length) {\n    if (this.pendingValue !== (this.pendingValue = value[0])) {\n      this.flags = ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = this.subs\n      if (subs !== undefined) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n    }\n  } else {\n    if (this.flags & ReactiveFlags.Dirty) {\n      if (updateSignal(this)) {\n        const subs = this.subs\n        if (subs !== undefined) {\n          shallowPropagate(subs)\n        }\n      }\n    }\n    let sub = activeSub\n    while (sub !== undefined) {\n      if (sub.flags & (ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n        link(this, sub, cycle)\n        break\n      }\n      sub = sub.subs?.sub\n    }\n    return this.currentValue\n  }\n}\n\nfunction effectOper(this: EffectNode): void {\n  effectScopeOper.call(this)\n}\n\nfunction effectScopeOper(this: ReactiveNode): void {\n  this.depsTail = undefined\n  this.flags = ReactiveFlags.None\n  purgeDeps(this)\n  const sub = this.subs\n  if (sub !== undefined) {\n    unlink(sub)\n  }\n}\n\nfunction purgeDeps(sub: ReactiveNode) {\n  const depsTail = sub.depsTail\n  let dep = depsTail !== undefined ? depsTail.nextDep : sub.deps\n  while (dep !== undefined) {\n    dep = unlink(dep, sub)\n  }\n}\n"],"names":["ReactiveFlags","link","unlink","propagate","checkDirty","shallowPropagate","effect"],"mappings":"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"}