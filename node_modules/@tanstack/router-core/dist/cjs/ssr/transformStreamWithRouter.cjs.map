{"version":3,"file":"transformStreamWithRouter.cjs","sources":["../../../src/ssr/transformStreamWithRouter.ts"],"sourcesContent":["import { ReadableStream } from 'node:stream/web'\nimport { Readable } from 'node:stream'\nimport { TSR_SCRIPT_BARRIER_ID } from './constants'\nimport type { AnyRouter } from '../router'\n\nexport function transformReadableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: ReadableStream,\n) {\n  return transformStreamWithRouter(router, routerStream)\n}\n\nexport function transformPipeableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: Readable,\n) {\n  return Readable.fromWeb(\n    transformStreamWithRouter(router, Readable.toWeb(routerStream)),\n  )\n}\n\n// Use string constants for simple indexOf matching\nconst BODY_END_TAG = '</body>'\nconst HTML_END_TAG = '</html>'\n\n// Minimum length of a valid closing tag: </a> = 4 characters\nconst MIN_CLOSING_TAG_LENGTH = 4\n\n// Default timeout values (in milliseconds)\nconst DEFAULT_SERIALIZATION_TIMEOUT_MS = 60000\nconst DEFAULT_LIFETIME_TIMEOUT_MS = 60000\n\n// Module-level encoder (stateless, safe to reuse)\nconst textEncoder = new TextEncoder()\n\n/**\n * Finds the position just after the last valid HTML closing tag in the string.\n *\n * Valid closing tags match the pattern: </[a-zA-Z][\\w:.-]*>\n * Examples: </div>, </my-component>, </slot:name.nested>\n *\n * @returns Position after the last closing tag, or -1 if none found\n */\nfunction findLastClosingTagEnd(str: string): number {\n  const len = str.length\n  if (len < MIN_CLOSING_TAG_LENGTH) return -1\n\n  let i = len - 1\n\n  while (i >= MIN_CLOSING_TAG_LENGTH - 1) {\n    // Look for > (charCode 62)\n    if (str.charCodeAt(i) === 62) {\n      // Look backwards for valid tag name characters\n      let j = i - 1\n\n      // Skip through valid tag name characters\n      while (j >= 1) {\n        const code = str.charCodeAt(j)\n        // Check if it's a valid tag name char: [a-zA-Z0-9_:.-]\n        if (\n          (code >= 97 && code <= 122) || // a-z\n          (code >= 65 && code <= 90) || // A-Z\n          (code >= 48 && code <= 57) || // 0-9\n          code === 95 || // _\n          code === 58 || // :\n          code === 46 || // .\n          code === 45 // -\n        ) {\n          j--\n        } else {\n          break\n        }\n      }\n\n      // Check if the first char after </ is a valid start char (letter only)\n      const tagNameStart = j + 1\n      if (tagNameStart < i) {\n        const startCode = str.charCodeAt(tagNameStart)\n        // Tag name must start with a letter (a-z or A-Z)\n        if (\n          (startCode >= 97 && startCode <= 122) ||\n          (startCode >= 65 && startCode <= 90)\n        ) {\n          // Check for </ (charCodes: < = 60, / = 47)\n          if (\n            j >= 1 &&\n            str.charCodeAt(j) === 47 &&\n            str.charCodeAt(j - 1) === 60\n          ) {\n            return i + 1 // Return position after the closing >\n          }\n        }\n      }\n    }\n    i--\n  }\n  return -1\n}\n\nexport function transformStreamWithRouter(\n  router: AnyRouter,\n  appStream: ReadableStream,\n  opts?: {\n    /** Timeout for serialization to complete after app render finishes (default: 60000ms) */\n    timeoutMs?: number\n    /** Maximum lifetime of the stream transform (default: 60000ms). Safety net for cleanup. */\n    lifetimeMs?: number\n  },\n) {\n  // Check upfront if serialization already finished synchronously\n  // This is the fast path for routes with no deferred data\n  const serializationAlreadyFinished =\n    router.serverSsr?.isSerializationFinished() ?? false\n\n  // Take any HTML that was buffered before we started listening\n  const initialBufferedHtml = router.serverSsr?.takeBufferedHtml()\n\n  // True passthrough: if serialization already finished and nothing buffered,\n  // we can avoid any decoding/scanning while still honoring cleanup + setRenderFinished.\n  if (serializationAlreadyFinished && !initialBufferedHtml) {\n    let cleanedUp = false\n    let controller: ReadableStreamDefaultController<Uint8Array> | undefined\n    let isStreamClosed = false\n    let lifetimeTimeoutHandle: ReturnType<typeof setTimeout> | undefined\n\n    const cleanup = () => {\n      if (cleanedUp) return\n      cleanedUp = true\n\n      if (lifetimeTimeoutHandle !== undefined) {\n        clearTimeout(lifetimeTimeoutHandle)\n        lifetimeTimeoutHandle = undefined\n      }\n\n      router.serverSsr?.cleanup()\n    }\n\n    const safeClose = () => {\n      if (isStreamClosed) return\n      isStreamClosed = true\n      try {\n        controller?.close()\n      } catch {\n        // ignore\n      }\n    }\n\n    const safeError = (error: unknown) => {\n      if (isStreamClosed) return\n      isStreamClosed = true\n      try {\n        controller?.error(error)\n      } catch {\n        // ignore\n      }\n    }\n\n    const lifetimeMs = opts?.lifetimeMs ?? DEFAULT_LIFETIME_TIMEOUT_MS\n    lifetimeTimeoutHandle = setTimeout(() => {\n      if (!cleanedUp && !isStreamClosed) {\n        console.warn(\n          `SSR stream transform exceeded maximum lifetime (${lifetimeMs}ms), forcing cleanup`,\n        )\n        safeError(new Error('Stream lifetime exceeded'))\n        cleanup()\n      }\n    }, lifetimeMs)\n\n    const stream = new ReadableStream<Uint8Array>({\n      start(c) {\n        controller = c\n      },\n      cancel() {\n        isStreamClosed = true\n        cleanup()\n      },\n    })\n\n    ;(async () => {\n      const reader = appStream.getReader()\n      try {\n        while (true) {\n          const { done, value } = await reader.read()\n          if (done) break\n          if (cleanedUp || isStreamClosed) return\n          controller?.enqueue(value as unknown as Uint8Array)\n        }\n\n        if (cleanedUp || isStreamClosed) return\n\n        router.serverSsr?.setRenderFinished()\n        safeClose()\n        cleanup()\n      } catch (error) {\n        if (cleanedUp) return\n        console.error('Error reading appStream:', error)\n        router.serverSsr?.setRenderFinished()\n        safeError(error)\n        cleanup()\n      } finally {\n        reader.releaseLock()\n      }\n    })().catch((error) => {\n      if (cleanedUp) return\n      console.error('Error in stream transform:', error)\n      safeError(error)\n      cleanup()\n    })\n\n    return stream\n  }\n\n  let stopListeningToInjectedHtml: (() => void) | undefined\n  let stopListeningToSerializationFinished: (() => void) | undefined\n  let serializationTimeoutHandle: ReturnType<typeof setTimeout> | undefined\n  let lifetimeTimeoutHandle: ReturnType<typeof setTimeout> | undefined\n  let cleanedUp = false\n\n  let controller: ReadableStreamDefaultController<any>\n  let isStreamClosed = false\n\n  const textDecoder = new TextDecoder()\n\n  // concat'd router HTML; avoids array joins on each flush\n  let pendingRouterHtml = initialBufferedHtml ?? ''\n\n  // between-chunk text buffer; keep bounded to avoid unbounded memory\n  let leftover = ''\n\n  // captured closing tags from </body> onward\n  let pendingClosingTags = ''\n\n  // conservative cap: enough to hold any partial closing tag + a bit\n  const MAX_LEFTOVER_CHARS = 2048\n\n  let isAppRendering = true\n  let streamBarrierLifted = false\n  let serializationFinished = serializationAlreadyFinished\n\n  function safeEnqueue(chunk: string | Uint8Array) {\n    if (isStreamClosed) return\n    if (typeof chunk === 'string') {\n      controller.enqueue(textEncoder.encode(chunk))\n    } else {\n      controller.enqueue(chunk)\n    }\n  }\n\n  function safeClose() {\n    if (isStreamClosed) return\n    isStreamClosed = true\n    try {\n      controller.close()\n    } catch {\n      // ignore\n    }\n  }\n\n  function safeError(error: unknown) {\n    if (isStreamClosed) return\n    isStreamClosed = true\n    try {\n      controller.error(error)\n    } catch {\n      // ignore\n    }\n  }\n\n  /**\n   * Cleanup with guards; must be idempotent.\n   */\n  function cleanup() {\n    if (cleanedUp) return\n    cleanedUp = true\n\n    try {\n      stopListeningToInjectedHtml?.()\n      stopListeningToSerializationFinished?.()\n    } catch {\n      // ignore\n    }\n    stopListeningToInjectedHtml = undefined\n    stopListeningToSerializationFinished = undefined\n\n    if (serializationTimeoutHandle !== undefined) {\n      clearTimeout(serializationTimeoutHandle)\n      serializationTimeoutHandle = undefined\n    }\n    if (lifetimeTimeoutHandle !== undefined) {\n      clearTimeout(lifetimeTimeoutHandle)\n      lifetimeTimeoutHandle = undefined\n    }\n\n    pendingRouterHtml = ''\n    leftover = ''\n    pendingClosingTags = ''\n\n    router.serverSsr?.cleanup()\n  }\n\n  const stream = new ReadableStream({\n    start(c) {\n      controller = c\n    },\n    cancel() {\n      isStreamClosed = true\n      cleanup()\n    },\n  })\n\n  function flushPendingRouterHtml() {\n    if (!pendingRouterHtml) return\n    safeEnqueue(pendingRouterHtml)\n    pendingRouterHtml = ''\n  }\n\n  function appendRouterHtml(html: string) {\n    if (!html) return\n    pendingRouterHtml += html\n  }\n\n  /**\n   * Finish only when app done and serialization complete.\n   */\n  function tryFinish() {\n    if (isAppRendering || !serializationFinished) return\n    if (cleanedUp || isStreamClosed) return\n\n    if (serializationTimeoutHandle !== undefined) {\n      clearTimeout(serializationTimeoutHandle)\n      serializationTimeoutHandle = undefined\n    }\n\n    // Flush any remaining bytes in the TextDecoder\n    const decoderRemainder = textDecoder.decode()\n\n    if (leftover) safeEnqueue(leftover)\n    if (decoderRemainder) safeEnqueue(decoderRemainder)\n    flushPendingRouterHtml()\n    if (pendingClosingTags) safeEnqueue(pendingClosingTags)\n\n    safeClose()\n    cleanup()\n  }\n\n  // Safety net: cleanup even if consumer never reads\n  const lifetimeMs = opts?.lifetimeMs ?? DEFAULT_LIFETIME_TIMEOUT_MS\n  lifetimeTimeoutHandle = setTimeout(() => {\n    if (!cleanedUp && !isStreamClosed) {\n      console.warn(\n        `SSR stream transform exceeded maximum lifetime (${lifetimeMs}ms), forcing cleanup`,\n      )\n      safeError(new Error('Stream lifetime exceeded'))\n      cleanup()\n    }\n  }, lifetimeMs)\n\n  if (!serializationAlreadyFinished) {\n    stopListeningToInjectedHtml = router.subscribe('onInjectedHtml', () => {\n      if (cleanedUp || isStreamClosed) return\n      const html = router.serverSsr?.takeBufferedHtml()\n      if (!html) return\n\n      // If we've already captured </body> (pendingClosingTags), we must keep appending\n      // so injection stays before the stored closing tags.\n      if (isAppRendering || leftover || pendingClosingTags) {\n        appendRouterHtml(html)\n      } else {\n        safeEnqueue(html)\n      }\n    })\n\n    stopListeningToSerializationFinished = router.subscribe(\n      'onSerializationFinished',\n      () => {\n        serializationFinished = true\n        tryFinish()\n      },\n    )\n  }\n\n  // Transform the appStream\n  ;(async () => {\n    const reader = appStream.getReader()\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) break\n\n        if (cleanedUp || isStreamClosed) return\n\n        const text =\n          value instanceof Uint8Array\n            ? textDecoder.decode(value, { stream: true })\n            : String(value)\n\n        // Fast path: most chunks have no pending left-over.\n        const chunkString = leftover ? leftover + text : text\n\n        if (!streamBarrierLifted) {\n          if (chunkString.includes(TSR_SCRIPT_BARRIER_ID)) {\n            streamBarrierLifted = true\n            router.serverSsr?.liftScriptBarrier()\n          }\n        }\n\n        // If we already saw </body>, everything else is part of tail; buffer it.\n        if (pendingClosingTags) {\n          pendingClosingTags += chunkString\n          leftover = ''\n          continue\n        }\n\n        const bodyEndIndex = chunkString.indexOf(BODY_END_TAG)\n        const htmlEndIndex = chunkString.indexOf(HTML_END_TAG)\n\n        if (\n          bodyEndIndex !== -1 &&\n          htmlEndIndex !== -1 &&\n          bodyEndIndex < htmlEndIndex\n        ) {\n          pendingClosingTags = chunkString.slice(bodyEndIndex)\n          safeEnqueue(chunkString.slice(0, bodyEndIndex))\n          flushPendingRouterHtml()\n          leftover = ''\n          continue\n        }\n\n        const lastClosingTagEnd = findLastClosingTagEnd(chunkString)\n\n        if (lastClosingTagEnd > 0) {\n          safeEnqueue(chunkString.slice(0, lastClosingTagEnd))\n          flushPendingRouterHtml()\n\n          leftover = chunkString.slice(lastClosingTagEnd)\n          if (leftover.length > MAX_LEFTOVER_CHARS) {\n            // Ensure bounded memory even if a consumer streams long text sequences\n            // without any closing tags. This may reduce injection granularity but is correct.\n            safeEnqueue(leftover.slice(0, leftover.length - MAX_LEFTOVER_CHARS))\n            leftover = leftover.slice(-MAX_LEFTOVER_CHARS)\n          }\n        } else {\n          // No closing tag found; keep small tail to handle split closing tags,\n          // but stream older bytes to prevent unbounded buffering.\n          const combined = chunkString\n          if (combined.length > MAX_LEFTOVER_CHARS) {\n            const flushUpto = combined.length - MAX_LEFTOVER_CHARS\n            safeEnqueue(combined.slice(0, flushUpto))\n            leftover = combined.slice(flushUpto)\n          } else {\n            leftover = combined\n          }\n        }\n      }\n\n      if (cleanedUp || isStreamClosed) return\n\n      isAppRendering = false\n      router.serverSsr?.setRenderFinished()\n\n      if (serializationFinished) {\n        tryFinish()\n      } else {\n        const timeoutMs = opts?.timeoutMs ?? DEFAULT_SERIALIZATION_TIMEOUT_MS\n        serializationTimeoutHandle = setTimeout(() => {\n          if (!cleanedUp && !isStreamClosed) {\n            console.error('Serialization timeout after app render finished')\n            safeError(\n              new Error('Serialization timeout after app render finished'),\n            )\n            cleanup()\n          }\n        }, timeoutMs)\n      }\n    } catch (error) {\n      if (cleanedUp) return\n      console.error('Error reading appStream:', error)\n      isAppRendering = false\n      router.serverSsr?.setRenderFinished()\n      safeError(error)\n      cleanup()\n    } finally {\n      reader.releaseLock()\n    }\n  })().catch((error) => {\n    if (cleanedUp) return\n    console.error('Error in stream transform:', error)\n    safeError(error)\n    cleanup()\n  })\n\n  return stream\n}\n"],"names":["Readable","cleanedUp","controller","isStreamClosed","lifetimeTimeoutHandle","cleanup","safeClose","safeError","lifetimeMs","stream","ReadableStream","TSR_SCRIPT_BARRIER_ID"],"mappings":";;;;;AAKO,SAAS,kCACd,QACA,cACA;AACA,SAAO,0BAA0B,QAAQ,YAAY;AACvD;AAEO,SAAS,kCACd,QACA,cACA;AACA,SAAOA,YAAAA,SAAS;AAAA,IACd,0BAA0B,QAAQA,qBAAS,MAAM,YAAY,CAAC;AAAA,EAAA;AAElE;AAGA,MAAM,eAAe;AACrB,MAAM,eAAe;AAGrB,MAAM,yBAAyB;AAG/B,MAAM,mCAAmC;AACzC,MAAM,8BAA8B;AAGpC,MAAM,cAAc,IAAI,YAAA;AAUxB,SAAS,sBAAsB,KAAqB;AAClD,QAAM,MAAM,IAAI;AAChB,MAAI,MAAM,uBAAwB,QAAO;AAEzC,MAAI,IAAI,MAAM;AAEd,SAAO,KAAK,yBAAyB,GAAG;AAEtC,QAAI,IAAI,WAAW,CAAC,MAAM,IAAI;AAE5B,UAAI,IAAI,IAAI;AAGZ,aAAO,KAAK,GAAG;AACb,cAAM,OAAO,IAAI,WAAW,CAAC;AAE7B,YACG,QAAQ,MAAM,QAAQ;AAAA,QACtB,QAAQ,MAAM,QAAQ;AAAA,QACtB,QAAQ,MAAM,QAAQ;AAAA,QACvB,SAAS;AAAA,QACT,SAAS;AAAA,QACT,SAAS;AAAA,QACT,SAAS,IACT;AACA;AAAA,QACF,OAAO;AACL;AAAA,QACF;AAAA,MACF;AAGA,YAAM,eAAe,IAAI;AACzB,UAAI,eAAe,GAAG;AACpB,cAAM,YAAY,IAAI,WAAW,YAAY;AAE7C,YACG,aAAa,MAAM,aAAa,OAChC,aAAa,MAAM,aAAa,IACjC;AAEA,cACE,KAAK,KACL,IAAI,WAAW,CAAC,MAAM,MACtB,IAAI,WAAW,IAAI,CAAC,MAAM,IAC1B;AACA,mBAAO,IAAI;AAAA,UACb;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,0BACd,QACA,WACA,MAMA;AAGA,QAAM,+BACJ,OAAO,WAAW,wBAAA,KAA6B;AAGjD,QAAM,sBAAsB,OAAO,WAAW,iBAAA;AAI9C,MAAI,gCAAgC,CAAC,qBAAqB;AACxD,QAAIC,aAAY;AAChB,QAAIC;AACJ,QAAIC,kBAAiB;AACrB,QAAIC;AAEJ,UAAMC,WAAU,MAAM;AACpB,UAAIJ,WAAW;AACfA,mBAAY;AAEZ,UAAIG,2BAA0B,QAAW;AACvC,qBAAaA,sBAAqB;AAClCA,iCAAwB;AAAA,MAC1B;AAEA,aAAO,WAAW,QAAA;AAAA,IACpB;AAEA,UAAME,aAAY,MAAM;AACtB,UAAIH,gBAAgB;AACpBA,wBAAiB;AACjB,UAAI;AACFD,qBAAY,MAAA;AAAA,MACd,QAAQ;AAAA,MAER;AAAA,IACF;AAEA,UAAMK,aAAY,CAAC,UAAmB;AACpC,UAAIJ,gBAAgB;AACpBA,wBAAiB;AACjB,UAAI;AACFD,qBAAY,MAAM,KAAK;AAAA,MACzB,QAAQ;AAAA,MAER;AAAA,IACF;AAEA,UAAMM,cAAa,MAAM,cAAc;AACvCJ,6BAAwB,WAAW,MAAM;AACvC,UAAI,CAACH,cAAa,CAACE,iBAAgB;AACjC,gBAAQ;AAAA,UACN,mDAAmDK,WAAU;AAAA,QAAA;AAE/DD,mBAAU,IAAI,MAAM,0BAA0B,CAAC;AAC/CF,iBAAAA;AAAAA,MACF;AAAA,IACF,GAAGG,WAAU;AAEb,UAAMC,UAAS,IAAIC,mBAA2B;AAAA,MAC5C,MAAM,GAAG;AACPR,sBAAa;AAAA,MACf;AAAA,MACA,SAAS;AACPC,0BAAiB;AACjBE,iBAAAA;AAAAA,MACF;AAAA,IAAA,CACD;AAEA,KAAC,YAAY;AACZ,YAAM,SAAS,UAAU,UAAA;AACzB,UAAI;AACF,eAAO,MAAM;AACX,gBAAM,EAAE,MAAM,MAAA,IAAU,MAAM,OAAO,KAAA;AACrC,cAAI,KAAM;AACV,cAAIJ,cAAaE,gBAAgB;AACjCD,uBAAY,QAAQ,KAA8B;AAAA,QACpD;AAEA,YAAID,cAAaE,gBAAgB;AAEjC,eAAO,WAAW,kBAAA;AAClBG,mBAAAA;AACAD,iBAAAA;AAAAA,MACF,SAAS,OAAO;AACd,YAAIJ,WAAW;AACf,gBAAQ,MAAM,4BAA4B,KAAK;AAC/C,eAAO,WAAW,kBAAA;AAClBM,mBAAU,KAAK;AACfF,iBAAAA;AAAAA,MACF,UAAA;AACE,eAAO,YAAA;AAAA,MACT;AAAA,IACF,GAAA,EAAK,MAAM,CAAC,UAAU;AACpB,UAAIJ,WAAW;AACf,cAAQ,MAAM,8BAA8B,KAAK;AACjDM,iBAAU,KAAK;AACfF,eAAAA;AAAAA,IACF,CAAC;AAED,WAAOI;AAAAA,EACT;AAEA,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,YAAY;AAEhB,MAAI;AACJ,MAAI,iBAAiB;AAErB,QAAM,cAAc,IAAI,YAAA;AAGxB,MAAI,oBAAoB,uBAAuB;AAG/C,MAAI,WAAW;AAGf,MAAI,qBAAqB;AAGzB,QAAM,qBAAqB;AAE3B,MAAI,iBAAiB;AACrB,MAAI,sBAAsB;AAC1B,MAAI,wBAAwB;AAE5B,WAAS,YAAY,OAA4B;AAC/C,QAAI,eAAgB;AACpB,QAAI,OAAO,UAAU,UAAU;AAC7B,iBAAW,QAAQ,YAAY,OAAO,KAAK,CAAC;AAAA,IAC9C,OAAO;AACL,iBAAW,QAAQ,KAAK;AAAA,IAC1B;AAAA,EACF;AAEA,WAAS,YAAY;AACnB,QAAI,eAAgB;AACpB,qBAAiB;AACjB,QAAI;AACF,iBAAW,MAAA;AAAA,IACb,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,WAAS,UAAU,OAAgB;AACjC,QAAI,eAAgB;AACpB,qBAAiB;AACjB,QAAI;AACF,iBAAW,MAAM,KAAK;AAAA,IACxB,QAAQ;AAAA,IAER;AAAA,EACF;AAKA,WAAS,UAAU;AACjB,QAAI,UAAW;AACf,gBAAY;AAEZ,QAAI;AACF,oCAAA;AACA,6CAAA;AAAA,IACF,QAAQ;AAAA,IAER;AACA,kCAA8B;AAC9B,2CAAuC;AAEvC,QAAI,+BAA+B,QAAW;AAC5C,mBAAa,0BAA0B;AACvC,mCAA6B;AAAA,IAC/B;AACA,QAAI,0BAA0B,QAAW;AACvC,mBAAa,qBAAqB;AAClC,8BAAwB;AAAA,IAC1B;AAEA,wBAAoB;AACpB,eAAW;AACX,yBAAqB;AAErB,WAAO,WAAW,QAAA;AAAA,EACpB;AAEA,QAAM,SAAS,IAAIC,mBAAe;AAAA,IAChC,MAAM,GAAG;AACP,mBAAa;AAAA,IACf;AAAA,IACA,SAAS;AACP,uBAAiB;AACjB,cAAA;AAAA,IACF;AAAA,EAAA,CACD;AAED,WAAS,yBAAyB;AAChC,QAAI,CAAC,kBAAmB;AACxB,gBAAY,iBAAiB;AAC7B,wBAAoB;AAAA,EACtB;AAEA,WAAS,iBAAiB,MAAc;AACtC,QAAI,CAAC,KAAM;AACX,yBAAqB;AAAA,EACvB;AAKA,WAAS,YAAY;AACnB,QAAI,kBAAkB,CAAC,sBAAuB;AAC9C,QAAI,aAAa,eAAgB;AAEjC,QAAI,+BAA+B,QAAW;AAC5C,mBAAa,0BAA0B;AACvC,mCAA6B;AAAA,IAC/B;AAGA,UAAM,mBAAmB,YAAY,OAAA;AAErC,QAAI,sBAAsB,QAAQ;AAClC,QAAI,8BAA8B,gBAAgB;AAClD,2BAAA;AACA,QAAI,gCAAgC,kBAAkB;AAEtD,cAAA;AACA,YAAA;AAAA,EACF;AAGA,QAAM,aAAa,MAAM,cAAc;AACvC,0BAAwB,WAAW,MAAM;AACvC,QAAI,CAAC,aAAa,CAAC,gBAAgB;AACjC,cAAQ;AAAA,QACN,mDAAmD,UAAU;AAAA,MAAA;AAE/D,gBAAU,IAAI,MAAM,0BAA0B,CAAC;AAC/C,cAAA;AAAA,IACF;AAAA,EACF,GAAG,UAAU;AAEb,MAAI,CAAC,8BAA8B;AACjC,kCAA8B,OAAO,UAAU,kBAAkB,MAAM;AACrE,UAAI,aAAa,eAAgB;AACjC,YAAM,OAAO,OAAO,WAAW,iBAAA;AAC/B,UAAI,CAAC,KAAM;AAIX,UAAI,kBAAkB,YAAY,oBAAoB;AACpD,yBAAiB,IAAI;AAAA,MACvB,OAAO;AACL,oBAAY,IAAI;AAAA,MAClB;AAAA,IACF,CAAC;AAED,2CAAuC,OAAO;AAAA,MAC5C;AAAA,MACA,MAAM;AACJ,gCAAwB;AACxB,kBAAA;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ;AAGC,GAAC,YAAY;AACZ,UAAM,SAAS,UAAU,UAAA;AACzB,QAAI;AACF,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAA,IAAU,MAAM,OAAO,KAAA;AACrC,YAAI,KAAM;AAEV,YAAI,aAAa,eAAgB;AAEjC,cAAM,OACJ,iBAAiB,aACb,YAAY,OAAO,OAAO,EAAE,QAAQ,KAAA,CAAM,IAC1C,OAAO,KAAK;AAGlB,cAAM,cAAc,WAAW,WAAW,OAAO;AAEjD,YAAI,CAAC,qBAAqB;AACxB,cAAI,YAAY,SAASC,UAAAA,qBAAqB,GAAG;AAC/C,kCAAsB;AACtB,mBAAO,WAAW,kBAAA;AAAA,UACpB;AAAA,QACF;AAGA,YAAI,oBAAoB;AACtB,gCAAsB;AACtB,qBAAW;AACX;AAAA,QACF;AAEA,cAAM,eAAe,YAAY,QAAQ,YAAY;AACrD,cAAM,eAAe,YAAY,QAAQ,YAAY;AAErD,YACE,iBAAiB,MACjB,iBAAiB,MACjB,eAAe,cACf;AACA,+BAAqB,YAAY,MAAM,YAAY;AACnD,sBAAY,YAAY,MAAM,GAAG,YAAY,CAAC;AAC9C,iCAAA;AACA,qBAAW;AACX;AAAA,QACF;AAEA,cAAM,oBAAoB,sBAAsB,WAAW;AAE3D,YAAI,oBAAoB,GAAG;AACzB,sBAAY,YAAY,MAAM,GAAG,iBAAiB,CAAC;AACnD,iCAAA;AAEA,qBAAW,YAAY,MAAM,iBAAiB;AAC9C,cAAI,SAAS,SAAS,oBAAoB;AAGxC,wBAAY,SAAS,MAAM,GAAG,SAAS,SAAS,kBAAkB,CAAC;AACnE,uBAAW,SAAS,MAAM,CAAC,kBAAkB;AAAA,UAC/C;AAAA,QACF,OAAO;AAGL,gBAAM,WAAW;AACjB,cAAI,SAAS,SAAS,oBAAoB;AACxC,kBAAM,YAAY,SAAS,SAAS;AACpC,wBAAY,SAAS,MAAM,GAAG,SAAS,CAAC;AACxC,uBAAW,SAAS,MAAM,SAAS;AAAA,UACrC,OAAO;AACL,uBAAW;AAAA,UACb;AAAA,QACF;AAAA,MACF;AAEA,UAAI,aAAa,eAAgB;AAEjC,uBAAiB;AACjB,aAAO,WAAW,kBAAA;AAElB,UAAI,uBAAuB;AACzB,kBAAA;AAAA,MACF,OAAO;AACL,cAAM,YAAY,MAAM,aAAa;AACrC,qCAA6B,WAAW,MAAM;AAC5C,cAAI,CAAC,aAAa,CAAC,gBAAgB;AACjC,oBAAQ,MAAM,iDAAiD;AAC/D;AAAA,cACE,IAAI,MAAM,iDAAiD;AAAA,YAAA;AAE7D,oBAAA;AAAA,UACF;AAAA,QACF,GAAG,SAAS;AAAA,MACd;AAAA,IACF,SAAS,OAAO;AACd,UAAI,UAAW;AACf,cAAQ,MAAM,4BAA4B,KAAK;AAC/C,uBAAiB;AACjB,aAAO,WAAW,kBAAA;AAClB,gBAAU,KAAK;AACf,cAAA;AAAA,IACF,UAAA;AACE,aAAO,YAAA;AAAA,IACT;AAAA,EACF,GAAA,EAAK,MAAM,CAAC,UAAU;AACpB,QAAI,UAAW;AACf,YAAQ,MAAM,8BAA8B,KAAK;AACjD,cAAU,KAAK;AACf,YAAA;AAAA,EACF,CAAC;AAED,SAAO;AACT;;;;"}